{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport InlineWorker from 'inline-worker';\nexport var Recorder = function () {\n  function Recorder(source, cfg) {\n    var _this = this;\n    _classCallCheck(this, Recorder);\n    this.config = _objectSpread({\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav'\n    }, cfg);\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n    this.node.onaudioprocess = function (e) {\n      if (!_this.recording) return;\n      var buffer = [];\n      for (var channel = 0; channel < _this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n      _this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n    source.connect(this.node);\n    this.node.connect(this.context.destination);\n\n    var self = {};\n    this.worker = new InlineWorker(function () {\n      var recLength = 0,\n        recBuffers = [],\n        sampleRate,\n        numChannels;\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n          case 'record':\n            record(e.data.buffer);\n            break;\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n          case 'getBuffer':\n            getBuffer();\n            break;\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n      var newSampleRate;\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n        recLength += inputBuffer[0].length;\n      }\n      function exportWAV(type) {\n        var buffers = [];\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        var interleaved;\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        var downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n        var dataview = encodeWAV(downSampledBuffer);\n        var audioBlob = new Blob([dataview], {\n          type: type\n        });\n        this.postMessage({\n          command: 'exportWAV',\n          data: audioBlob\n        });\n      }\n      function getBuffer() {\n        var buffers = [];\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        this.postMessage({\n          command: 'getBuffer',\n          data: buffers\n        });\n      }\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n      function initBuffers() {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n      function mergeBuffers(recBuffers, recLength) {\n        var result = new Float32Array(recLength);\n        var offset = 0;\n        for (var i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n        return result;\n      }\n      function interleave(inputL, inputR) {\n        var length = inputL.length + inputR.length;\n        var result = new Float32Array(length);\n        var index = 0,\n          inputIndex = 0;\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n        return result;\n      }\n      function floatTo16BitPCM(output, offset, input) {\n        for (var i = 0; i < input.length; i++, offset += 2) {\n          var s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n      function writeString(view, offset, string) {\n        for (var i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n          var accum = 0,\n            count = 0;\n          for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n          }\n          result[offsetResult] = accum / count;\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n        return result;\n      }\n      function encodeWAV(samples) {\n        var buffer = new ArrayBuffer(44 + samples.length * 2);\n        var view = new DataView(buffer);\n\n        writeString(view, 0, 'RIFF');\n        view.setUint32(4, 36 + samples.length * 2, true);\n        writeString(view, 8, 'WAVE');\n        writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        view.setUint16(22, numChannels, true);\n        view.setUint32(24, newSampleRate, true);\n        view.setUint32(28, newSampleRate * 4, true);\n        view.setUint16(32, numChannels * 2, true);\n        view.setUint16(34, 16, true);\n        writeString(view, 36, 'data');\n        view.setUint32(40, samples.length * 2, true);\n        floatTo16BitPCM(view, 44, samples);\n        return view;\n      }\n    }, self);\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n    this.worker.onmessage = function (e) {\n      var cb = _this.callbacks[e.data.command].pop();\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n  _createClass(Recorder, [{\n    key: \"record\",\n    value: function record() {\n      this.recording = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.recording = false;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.worker.postMessage({\n        command: 'clear'\n      });\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(cb) {\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.getBuffer.push(cb);\n      this.worker.postMessage({\n        command: 'getBuffer'\n      });\n    }\n  }, {\n    key: \"exportWAV\",\n    value: function exportWAV(cb, mimeType) {\n      mimeType = mimeType || this.config.mimeType;\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.exportWAV.push(cb);\n      this.worker.postMessage({\n        command: 'exportWAV',\n        type: mimeType\n      });\n    }\n  }], [{\n    key: \"forceDownload\",\n    value: function forceDownload(blob, filename) {\n      var url = (window.URL || window.webkitURL).createObjectURL(blob);\n      var link = window.document.createElement('a');\n      link.href = url;\n      link.download = filename || 'output.wav';\n      var click = document.createEvent('Event');\n      click.initEvent('click', true, true);\n      link.dispatchEvent(click);\n    }\n  }]);\n  return Recorder;\n}();\nexport default Recorder;","map":{"version":3,"names":["InlineWorker","Recorder","source","cfg","config","bufferLen","numChannels","mimeType","recording","callbacks","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","call","onaudioprocess","e","buffer","channel","push","inputBuffer","getChannelData","worker","postMessage","command","connect","destination","self","recLength","recBuffers","sampleRate","onmessage","data","init","record","type","clear","newSampleRate","initBuffers","length","buffers","mergeBuffers","interleaved","interleave","downSampledBuffer","downSampleBuffer","dataview","encodeWAV","audioBlob","Blob","result","Float32Array","offset","i","set","inputL","inputR","index","inputIndex","floatTo16BitPCM","output","input","s","Math","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","samples","ArrayBuffer","DataView","setUint32","setUint16","cb","pop","callback","Error","blob","filename","url","window","URL","webkitURL","createObjectURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent"],"sources":["C:/Users/netra/Documents/GitHub/RoutineRemind/screens/StudentScreen/Hooks/recorder.js"],"sourcesContent":["import InlineWorker from 'inline-worker';\n\nexport class Recorder {\n  constructor(source, cfg) {\n    this.config = {\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav',\n      ...cfg\n    };\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\n    ).call(\n      this.context,\n      this.config.bufferLen,\n      this.config.numChannels,\n      this.config.numChannels\n    );\n\n    this.node.onaudioprocess = (e) => {\n      if (!this.recording) return;\n\n      var buffer = [];\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n      this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    let self = {};\n    this.worker = new InlineWorker(function () {\n      let recLength = 0,\n        recBuffers = [],\n        sampleRate,\n        numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n          case 'record':\n            record(e.data.buffer);\n            break;\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n          case 'getBuffer':\n            getBuffer();\n            break;\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      let newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        let interleaved;\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        // converts sample rate to 48000 if higher than 48000\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n\n        let dataview = encodeWAV(downSampledBuffer);\n        let audioBlob = new Blob([dataview], { type: type });\n\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\n      }\n\n      function getBuffer() {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        this.postMessage({ command: 'getBuffer', data: buffers });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (let channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        let result = new Float32Array(recLength);\n        let offset = 0;\n        for (let i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        let length = inputL.length + inputR.length;\n        let result = new Float32Array(length);\n\n        let index = 0,\n          inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (let i = 0; i < input.length; i++, offset += 2) {\n          let s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      // Down sample buffer before WAV encoding\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round(\n            (offsetResult + 1) * sampleRateRatio\n          );\n          // Use average value of skipped samples\n          var accum = 0,\n            count = 0;\n          for (\n            var i = offsetBuffer;\n            i < nextOffsetBuffer && i < buffer.length;\n            i++\n          ) {\n            accum += buffer[i];\n            count++;\n          }\n          result[offsetResult] = accum / count;\n          // Or you can simply get rid of the skipped samples:\n          // result[offsetResult] = buffer[nextOffsetBuffer];\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\n        let view = new DataView(buffer);\n\n        /* RIFF identifier */\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n        view.setUint16(20, 1, true);\n        /* channel count */\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n        view.setUint32(24, newSampleRate, true);\n        /* byte rate (sample rate * block align) */\n        view.setUint32(28, newSampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n        writeString(view, 36, 'data');\n        /* data chunk length */\n        view.setUint32(40, samples.length * 2, true);\n\n        floatTo16BitPCM(view, 44, samples);\n\n        return view;\n      }\n    }, self);\n\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = (e) => {\n      let cb = this.callbacks[e.data.command].pop();\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  record() {\n    this.recording = true;\n  }\n\n  stop() {\n    this.recording = false;\n  }\n\n  clear() {\n    this.worker.postMessage({ command: 'clear' });\n  }\n\n  getBuffer(cb) {\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.getBuffer.push(cb);\n\n    this.worker.postMessage({ command: 'getBuffer' });\n  }\n\n  exportWAV(cb, mimeType) {\n    mimeType = mimeType || this.config.mimeType;\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.exportWAV.push(cb);\n\n    this.worker.postMessage({\n      command: 'exportWAV',\n      type: mimeType\n    });\n  }\n\n  static forceDownload(blob, filename) {\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\n    let link = window.document.createElement('a');\n    link.href = url;\n    link.download = filename || 'output.wav';\n    let click = document.createEvent('Event');\n    click.initEvent('click', true, true);\n    link.dispatchEvent(click);\n  }\n}\n\nexport default Recorder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}